---
layout:     post
title:      Tarjan求强连通分量
subtitle:   模板
date:       2019-02-28
author:     qwqcxh
header-img: img/in-post/模板类壁纸/model.jpg
catalog: true
tags:
    - 模板
    - Tarjan
---

## 需求
要求在O(n)的时间得到一个有向图的所有强连通分支数，以及每个分支所包含的节点。可以用Tarjan算法实现。
该算法基于DFS，使用两个数组dfn以及low,分别维护一个点的时间戳以及该点子孙节点（包括自身）所能追溯到
最小dfn值的祖先节点。从某个点开始进行深搜，遍历子节点，如果该节点尚未访问，递归调用Tarjan,重新计算low
否则如果该节点已经访问过且在栈中也重新计算low,栈用来存放DFS序列，如果该点Tarjan完后low==dfn,那么
说明该点是强连通分支的根节点。从栈中取出该部分值即可。

## 代码
```
#include <iostream>
#include <vector>
#include <stack>

using namespace std;
#define MAXN 100010

int u[MAXN],v[MAXN];
int en=1;
int first[MAXN],nxt[MAXN];
void adde(int uu,int vv){
    nxt[en]=first[uu];
    u[en]=uu;v[en]=vv;
    first[uu]=en++;
}
/***********Tarjan模板*******************/
int clk=0;
int dfn[MAXN],low[MAXN],inq[MAXN];
int stk[MAXN];int top=-1;
vector<int> scc[MAXN];int sum=0;//强联通分量以及总数
void Tarjan(int s){
    low[s]=dfn[s]=++clk;
    stk[++top]=s;
    inq[s]=1;
    for(int i=first[s];i;i=nxt[i]){
        int t=v[i];
        if(!dfn[t]){//遇到一个没有遍历到的
            Tarjan(t);
            low[s]=min(low[s],low[t]);
        }
        else if(inq[t])
            low[s]=min(low[s],low[t]);
    }
    if(dfn[s]==low[s]){
        while(stk[top]!=s){
            scc[sum].push_back(stk[top]);
            inq[stk[top--] ] =0;
        }
        scc[sum].push_back(stk[top]);
        inq[stk[top--]] = 0;
        sum++;
    }
}
void find_scc(int n){//有效编号1-n的结点
    for(int i=1;i<=n;i++)
        if(dfn[i]==0)
            Tarjan(i);
}
/****************模板end*******************/
int main()
{
    input 
    find_scc(n);
    output
    return 0;
}

```